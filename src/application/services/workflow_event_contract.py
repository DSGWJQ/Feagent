"""Workflow event semantics & boundary contracts.

This module intentionally provides a *minimal* set of constants and validators to
freeze the public-facing semantics of workflow-related events.

We distinguish three categories at the API boundary:

1) planning
   - Events describing workflow planning / reasoning progress.
   - These are not proof of real tool execution and must not be mixed into
     workflow execution streams.

2) tool_call
   - Events representing real tool execution (e.g., ConversationAgent calling a
     ToolCallExecutor/ToolEngine). These MUST be generated by the execution
     engine, not "replayed" from plain LLM text.

3) execution
   - Events representing workflow node execution progress emitted by
     `/api/workflows/{workflow_id}/execute/stream` and persisted as RunEvents.
   - Contract: only `node_*` and `workflow_*` types are allowed.
   - Required fields: `type`, `run_id`, `executor_id`.

KISS: we validate only what is required to enforce the boundary and keep
execution streams free of planning/tool_call artifacts.
"""

from __future__ import annotations

from collections.abc import Mapping
from typing import Any

# Public contract (execution stream)
EXECUTION_EVENT_TYPE_PREFIXES: tuple[str, ...] = ("node_", "workflow_")
EXECUTION_DISALLOWED_EVENT_TYPES: frozenset[str] = frozenset(
    {
        # Explicitly reserved for non-execution semantics.
        "planning",
        "tool_call",
        "tool_result",
    }
)


class ExecutionEventContractError(ValueError):
    """Raised when a workflow execution SSE event violates the public contract."""


def is_execution_event_type(event_type: str) -> bool:
    normalized = (event_type or "").strip()
    if not normalized:
        return False
    if normalized in EXECUTION_DISALLOWED_EVENT_TYPES:
        return False
    return normalized.startswith(EXECUTION_EVENT_TYPE_PREFIXES)


def validate_workflow_execution_sse_event(event: Mapping[str, Any]) -> None:
    """Validate an execution SSE event against the frozen contract.

    Raises:
        ExecutionEventContractError: when the event is invalid and must not be emitted.
    """

    event_type = event.get("type")
    if not isinstance(event_type, str) or not is_execution_event_type(event_type):
        raise ExecutionEventContractError(f"invalid execution event type: {event_type!r}")

    run_id = event.get("run_id")
    if not isinstance(run_id, str) or not run_id.strip():
        raise ExecutionEventContractError("execution event missing run_id")

    executor_id = event.get("executor_id")
    if not isinstance(executor_id, str) or not executor_id.strip():
        raise ExecutionEventContractError("execution event missing executor_id")
