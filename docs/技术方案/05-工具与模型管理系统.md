# å·¥å…·ä¸Žæ¨¡åž‹ç®¡ç†ç³»ç»Ÿ

> **æŠ€æœ¯æ–¹æ¡ˆæ–‡æ¡£**
> é¡¹ç›®åç§°ï¼šFeagent
> æ–‡æ¡£è¯´æ˜Žï¼šæœ¬æ–‡æ¡£æè¿°å·¥å…·å’ŒLLMæä¾›å•†çš„ç”Ÿå‘½å‘¨æœŸç®¡ç†æ–¹æ¡ˆ

---

## ðŸŽ¯ ç³»ç»Ÿæ¦‚è¿°

### ç®¡ç†ç›®æ ‡
1. **å·¥å…·ç®¡ç†**ï¼šåˆ›å»ºã€æµ‹è¯•ã€å‘å¸ƒã€ä½¿ç”¨ã€ç»´æŠ¤ã€é€€å½¹çš„å®Œæ•´ç”Ÿå‘½å‘¨æœŸ
2. **æ¨¡åž‹ç®¡ç†**ï¼šå¤šLLMæä¾›å•†æŽ¥å…¥ã€é…ç½®ã€åˆ‡æ¢ã€ç›‘æŽ§
3. **ç‰ˆæœ¬æŽ§åˆ¶**ï¼šå·¥å…·ç‰ˆæœ¬è¿­ä»£ã€å…¼å®¹æ€§ç®¡ç†
4. **æƒé™æŽ§åˆ¶**ï¼šå·¥å…·å¯è§æ€§ã€ä½¿ç”¨æƒé™ç®¡ç†
5. **æˆæœ¬ä¼˜åŒ–**ï¼šæ¨¡åž‹è°ƒç”¨æˆæœ¬è·Ÿè¸ªã€é¢„ç®—æŽ§åˆ¶

---

## ðŸ› ï¸ å·¥å…·ç®¡ç†ç³»ç»Ÿ

### å·¥å…·ç”Ÿå‘½å‘¨æœŸ

```
åˆ›å»º â†’ æµ‹è¯• â†’ å‘å¸ƒ â†’ ä½¿ç”¨ â†’ ç»´æŠ¤ â†’ é€€å½¹
 â†“      â†“      â†“      â†“      â†“      â†“
è‰ç¨¿   å†…æµ‹    æ­£å¼   ç”Ÿäº§   æ›´æ–°   åºŸå¼ƒ
```

### Domainå±‚ï¼šå·¥å…·å®žä½“

```python
# src/domain/entities/tool.py
from dataclasses import dataclass, field
from datetime import datetime
from enum import Enum
from typing import Dict, Any, List

class ToolStatus(str, Enum):
    """å·¥å…·çŠ¶æ€"""
    DRAFT = "draft"         # è‰ç¨¿
    TESTING = "testing"     # æµ‹è¯•ä¸­
    PUBLISHED = "published" # å·²å‘å¸ƒ
    DEPRECATED = "deprecated"  # å·²åºŸå¼ƒ

class ToolCategory(str, Enum):
    """å·¥å…·åˆ†ç±»"""
    HTTP = "http"           # HTTPè¯·æ±‚
    DATABASE = "database"   # æ•°æ®åº“æ“ä½œ
    FILE = "file"           # æ–‡ä»¶å¤„ç†
    AI = "ai"               # AIå·¥å…·
    NOTIFICATION = "notification"  # é€šçŸ¥
    CUSTOM = "custom"       # è‡ªå®šä¹‰

@dataclass
class ToolParameter:
    """å·¥å…·å‚æ•°å®šä¹‰"""
    name: str
    type: str  # string, number, boolean, object, array
    description: str
    required: bool = False
    default: Any = None
    enum: List[str] | None = None  # æžšä¸¾å€¼

@dataclass
class Tool:
    """å·¥å…·èšåˆæ ¹"""
    id: str
    name: str
    description: str
    category: ToolCategory
    status: ToolStatus
    version: str  # è¯­ä¹‰åŒ–ç‰ˆæœ¬ (e.g., "1.0.0")

    # å·¥å…·å®šä¹‰
    parameters: List[ToolParameter]
    returns: Dict[str, Any]  # è¿”å›žå€¼schema

    # å®žçŽ°æ–¹å¼
    implementation_type: str  # builtin, http, javascript, python
    implementation_config: Dict[str, Any]

    # å…ƒæ•°æ®
    author: str
    tags: List[str] = field(default_factory=list)
    icon: str | None = None

    # ä½¿ç”¨ç»Ÿè®¡
    usage_count: int = 0
    last_used_at: datetime | None = None

    # æ—¶é—´æˆ³
    created_at: datetime = field(default_factory=datetime.now)
    updated_at: datetime | None = None
    published_at: datetime | None = None

    @staticmethod
    def create(
        name: str,
        description: str,
        category: ToolCategory,
        author: str,
        **kwargs
    ) -> "Tool":
        """åˆ›å»ºå·¥å…·ï¼ˆè‰ç¨¿çŠ¶æ€ï¼‰"""
        from src.domain.value_objects import generate_id

        if not name or not name.strip():
            raise ValueError("å·¥å…·åç§°ä¸èƒ½ä¸ºç©º")

        return Tool(
            id=generate_id(),
            name=name.strip(),
            description=description,
            category=category,
            status=ToolStatus.DRAFT,
            version="0.1.0",
            parameters=[],
            returns={},
            implementation_type="builtin",
            implementation_config={},
            author=author,
            **kwargs
        )

    def publish(self) -> None:
        """å‘å¸ƒå·¥å…·"""
        if self.status != ToolStatus.TESTING:
            raise ValueError("åªæœ‰æµ‹è¯•é€šè¿‡çš„å·¥å…·æ‰èƒ½å‘å¸ƒ")

        self.status = ToolStatus.PUBLISHED
        self.published_at = datetime.now()

    def deprecate(self, reason: str) -> None:
        """åºŸå¼ƒå·¥å…·"""
        self.status = ToolStatus.DEPRECATED
        self.implementation_config["deprecation_reason"] = reason
        self.updated_at = datetime.now()

    def increment_usage(self) -> None:
        """å¢žåŠ ä½¿ç”¨è®¡æ•°"""
        self.usage_count += 1
        self.last_used_at = datetime.now()
```

### å·¥å…·åˆ†ç±»ä¸Žé¢„å®šä¹‰å·¥å…·

#### HTTPå·¥å…·
```python
HTTP_REQUEST_TOOL = Tool(
    id="builtin_http_request",
    name="HTTPè¯·æ±‚",
    description="å‘é€HTTPè¯·æ±‚èŽ·å–æ•°æ®",
    category=ToolCategory.HTTP,
    status=ToolStatus.PUBLISHED,
    version="1.0.0",
    parameters=[
        ToolParameter(name="url", type="string", description="è¯·æ±‚URL", required=True),
        ToolParameter(name="method", type="string", description="HTTPæ–¹æ³•", required=True, enum=["GET", "POST", "PUT", "DELETE"]),
        ToolParameter(name="headers", type="object", description="è¯·æ±‚å¤´", required=False),
        ToolParameter(name="body", type="object", description="è¯·æ±‚ä½“", required=False),
        ToolParameter(name="timeout", type="number", description="è¶…æ—¶æ—¶é—´ï¼ˆç§’ï¼‰", default=30)
    ],
    returns={
        "status_code": "number",
        "headers": "object",
        "body": "any"
    },
    implementation_type="builtin",
    implementation_config={},
    author="system"
)
```

#### LLMå·¥å…·
```python
LLM_CALL_TOOL = Tool(
    id="builtin_llm_call",
    name="LLMè°ƒç”¨",
    description="è°ƒç”¨å¤§è¯­è¨€æ¨¡åž‹å¤„ç†æ–‡æœ¬",
    category=ToolCategory.AI,
    status=ToolStatus.PUBLISHED,
    version="1.0.0",
    parameters=[
        ToolParameter(name="provider", type="string", description="LLMæä¾›å•†", required=True, enum=["openai", "deepseek", "qwen"]),
        ToolParameter(name="model", type="string", description="æ¨¡åž‹åç§°", required=True),
        ToolParameter(name="messages", type="array", description="å¯¹è¯æ¶ˆæ¯", required=True),
        ToolParameter(name="temperature", type="number", description="æ¸©åº¦", default=0.7),
        ToolParameter(name="max_tokens", type="number", description="æœ€å¤§Tokenæ•°", default=1000)
    ],
    returns={
        "content": "string",
        "usage": "object"
    },
    implementation_type="builtin",
    implementation_config={},
    author="system"
)
```

### å·¥å…·æ‰§è¡Œå™¨

```python
# src/infrastructure/executors/tool_executor.py
from typing import Dict, Any
from src.domain.entities.tool import Tool

class ToolExecutor:
    """å·¥å…·æ‰§è¡Œå™¨åŸºç±»"""

    async def execute(self, tool: Tool, input_data: Dict[str, Any]) -> Dict[str, Any]:
        """æ‰§è¡Œå·¥å…·"""
        # 1. å‚æ•°æ ¡éªŒ
        self._validate_parameters(tool, input_data)

        # 2. æ ¹æ®implementation_typeåˆ†å‘
        if tool.implementation_type == "builtin":
            return await self._execute_builtin(tool, input_data)
        elif tool.implementation_type == "http":
            return await self._execute_http(tool, input_data)
        elif tool.implementation_type == "javascript":
            return await self._execute_javascript(tool, input_data)
        else:
            raise ValueError(f"ä¸æ”¯æŒçš„å®žçŽ°ç±»åž‹: {tool.implementation_type}")

    def _validate_parameters(self, tool: Tool, input_data: Dict[str, Any]) -> None:
        """æ ¡éªŒå‚æ•°"""
        for param in tool.parameters:
            if param.required and param.name not in input_data:
                raise ValueError(f"ç¼ºå°‘å¿…éœ€å‚æ•°: {param.name}")

            # TODO: ç±»åž‹æ ¡éªŒã€æžšä¸¾æ ¡éªŒç­‰

    async def _execute_builtin(self, tool: Tool, input_data: Dict[str, Any]) -> Dict[str, Any]:
        """æ‰§è¡Œå†…ç½®å·¥å…·"""
        if tool.id == "builtin_http_request":
            return await self._http_request(input_data)
        elif tool.id == "builtin_llm_call":
            return await self._llm_call(input_data)
        else:
            raise ValueError(f"æœªçŸ¥çš„å†…ç½®å·¥å…·: {tool.id}")

    async def _http_request(self, input_data: Dict[str, Any]) -> Dict[str, Any]:
        """æ‰§è¡ŒHTTPè¯·æ±‚"""
        import httpx

        async with httpx.AsyncClient() as client:
            response = await client.request(
                method=input_data["method"],
                url=input_data["url"],
                headers=input_data.get("headers"),
                json=input_data.get("body"),
                timeout=input_data.get("timeout", 30)
            )

            return {
                "status_code": response.status_code,
                "headers": dict(response.headers),
                "body": response.json() if response.headers.get("content-type") == "application/json" else response.text
            }

    async def _llm_call(self, input_data: Dict[str, Any]) -> Dict[str, Any]:
        """è°ƒç”¨LLM"""
        # æ ¹æ®providerè°ƒç”¨ä¸åŒçš„LLMæœåŠ¡
        provider = input_data["provider"]

        if provider == "openai":
            return await self._call_openai(input_data)
        elif provider == "deepseek":
            return await self._call_deepseek(input_data)
        else:
            raise ValueError(f"ä¸æ”¯æŒçš„LLMæä¾›å•†: {provider}")

    async def _call_openai(self, input_data: Dict[str, Any]) -> Dict[str, Any]:
        """è°ƒç”¨OpenAI API"""
        from openai import AsyncOpenAI

        client = AsyncOpenAI()
        response = await client.chat.completions.create(
            model=input_data["model"],
            messages=input_data["messages"],
            temperature=input_data.get("temperature", 0.7),
            max_tokens=input_data.get("max_tokens", 1000)
        )

        return {
            "content": response.choices[0].message.content,
            "usage": {
                "prompt_tokens": response.usage.prompt_tokens,
                "completion_tokens": response.usage.completion_tokens,
                "total_tokens": response.usage.total_tokens
            }
        }
```

---

## ðŸ¤– LLMæä¾›å•†ç®¡ç†

### æ”¯æŒçš„æä¾›å•†

| æä¾›å•† | æ¨¡åž‹ç¤ºä¾‹ | APIå…¼å®¹æ€§ | æˆæœ¬ | é€Ÿåº¦ |
|-------|---------|----------|------|------|
| **OpenAI** | GPT-4, GPT-3.5 | å®˜æ–¹æ ‡å‡† | â­â­â­â­ | â­â­â­ |
| **DeepSeek** | deepseek-chat | OpenAIå…¼å®¹ | â­â­ | â­â­â­â­ |
| **Qwen (é€šä¹‰åƒé—®)** | qwen-turbo, qwen-plus | OpenAIå…¼å®¹ | â­â­â­ | â­â­â­â­ |
| **Anthropic** | Claude-3 | å®˜æ–¹SDK | â­â­â­â­ | â­â­â­ |
| **æœ¬åœ°æ¨¡åž‹** | Ollama | OpenAIå…¼å®¹ | â­ | â­â­ |

### Domainå±‚ï¼šLLMé…ç½®å®žä½“

```python
# src/domain/entities/llm_config.py
from dataclasses import dataclass
from datetime import datetime
from typing import Dict, Any

@dataclass
class LLMProvider:
    """LLMæä¾›å•†é…ç½®"""
    id: str
    name: str  # openai, deepseek, qwen, anthropic, ollama
    display_name: str
    api_base: str
    api_key: str | None  # åŠ å¯†å­˜å‚¨
    models: list[str]
    enabled: bool = True
    config: Dict[str, Any] = None  # é¢å¤–é…ç½®
    created_at: datetime = None
    updated_at: datetime | None = None

    @staticmethod
    def create_openai(api_key: str) -> "LLMProvider":
        from src.domain.value_objects import generate_id

        return LLMProvider(
            id=generate_id(),
            name="openai",
            display_name="OpenAI",
            api_base="https://api.openai.com/v1",
            api_key=api_key,
            models=["gpt-4", "gpt-4-turbo", "gpt-3.5-turbo"],
            created_at=datetime.now()
        )

    @staticmethod
    def create_deepseek(api_key: str) -> "LLMProvider":
        from src.domain.value_objects import generate_id

        return LLMProvider(
            id=generate_id(),
            name="deepseek",
            display_name="DeepSeek",
            api_base="https://api.deepseek.com/v1",
            api_key=api_key,
            models=["deepseek-chat", "deepseek-coder"],
            created_at=datetime.now()
        )
```

### LLMè°ƒç”¨ç»Ÿä¸€æŽ¥å£

```python
# src/infrastructure/llm/llm_client.py
from typing import List, Dict, Any
from openai import AsyncOpenAI
from src.domain.entities.llm_config import LLMProvider

class LLMClient:
    """LLMç»Ÿä¸€è°ƒç”¨å®¢æˆ·ç«¯"""

    def __init__(self, provider: LLMProvider):
        self.provider = provider
        self.client = AsyncOpenAI(
            api_key=provider.api_key,
            base_url=provider.api_base
        )

    async def chat_completion(
        self,
        model: str,
        messages: List[Dict[str, str]],
        temperature: float = 0.7,
        max_tokens: int = 1000
    ) -> Dict[str, Any]:
        """èŠå¤©è¡¥å…¨"""
        response = await self.client.chat.completions.create(
            model=model,
            messages=messages,
            temperature=temperature,
            max_tokens=max_tokens
        )

        return {
            "content": response.choices[0].message.content,
            "usage": {
                "prompt_tokens": response.usage.prompt_tokens,
                "completion_tokens": response.usage.completion_tokens,
                "total_tokens": response.usage.total_tokens
            },
            "model": response.model,
            "finish_reason": response.choices[0].finish_reason
        }

    async def get_available_models(self) -> List[str]:
        """èŽ·å–å¯ç”¨æ¨¡åž‹åˆ—è¡¨"""
        return self.provider.models
```

### æˆæœ¬è·Ÿè¸ª

```python
# src/domain/entities/llm_usage.py
from dataclasses import dataclass
from datetime import datetime

@dataclass
class LLMUsage:
    """LLMä½¿ç”¨è®°å½•"""
    id: str
    provider: str
    model: str
    prompt_tokens: int
    completion_tokens: int
    total_tokens: int
    cost: float  # ç¾Žå…ƒ
    run_id: str
    task_id: str
    created_at: datetime

    @staticmethod
    def calculate_cost(provider: str, model: str, prompt_tokens: int, completion_tokens: int) -> float:
        """è®¡ç®—æˆæœ¬"""
        # OpenAIä»·æ ¼è¡¨ï¼ˆç¤ºä¾‹ï¼‰
        PRICING = {
            "openai": {
                "gpt-4": {"prompt": 0.03 / 1000, "completion": 0.06 / 1000},
                "gpt-3.5-turbo": {"prompt": 0.001 / 1000, "completion": 0.002 / 1000}
            },
            "deepseek": {
                "deepseek-chat": {"prompt": 0.0007 / 1000, "completion": 0.002 / 1000}
            }
        }

        pricing = PRICING.get(provider, {}).get(model, {"prompt": 0, "completion": 0})
        cost = (prompt_tokens * pricing["prompt"]) + (completion_tokens * pricing["completion"])
        return round(cost, 6)
```

---

## ðŸ“Š å·¥å…·å¸‚åœºï¼ˆæœªæ¥è§„åˆ’ï¼‰

### å·¥å…·å‘çŽ°ä¸Žå…±äº«

```python
@dataclass
class ToolMarketplace:
    """å·¥å…·å¸‚åœº"""

    @staticmethod
    async def search_tools(
        keyword: str | None = None,
        category: ToolCategory | None = None,
        sort_by: str = "popularity"  # popularity, latest, rating
    ) -> List[Tool]:
        """æœç´¢å·¥å…·"""
        pass

    @staticmethod
    async def install_tool(tool_id: str) -> Tool:
        """å®‰è£…å·¥å…·åˆ°æœ¬åœ°"""
        pass

    @staticmethod
    async def publish_tool(tool: Tool) -> None:
        """å‘å¸ƒå·¥å…·åˆ°å¸‚åœº"""
        pass
```

### å·¥å…·è¯„ä»·ä¸Žè¯„åˆ†

```python
@dataclass
class ToolReview:
    """å·¥å…·è¯„ä»·"""
    id: str
    tool_id: str
    user_id: str
    rating: int  # 1-5æ˜Ÿ
    comment: str
    created_at: datetime
```

---

## ðŸ” æƒé™ä¸Žå®‰å…¨

### å·¥å…·æƒé™æŽ§åˆ¶

```python
class ToolPermission(str, Enum):
    """å·¥å…·æƒé™"""
    VIEW = "view"       # æŸ¥çœ‹
    USE = "use"         # ä½¿ç”¨
    EDIT = "edit"       # ç¼–è¾‘
    DELETE = "delete"   # åˆ é™¤
    PUBLISH = "publish" # å‘å¸ƒ

@dataclass
class ToolAccessControl:
    """å·¥å…·è®¿é—®æŽ§åˆ¶"""
    tool_id: str
    user_id: str
    permissions: List[ToolPermission]
```

### APIå¯†é’¥åŠ å¯†å­˜å‚¨

```python
# src/infrastructure/security/encryption.py
from cryptography.fernet import Fernet

class EncryptionService:
    """åŠ å¯†æœåŠ¡"""

    def __init__(self, key: bytes):
        self.cipher = Fernet(key)

    def encrypt(self, plaintext: str) -> str:
        """åŠ å¯†"""
        return self.cipher.encrypt(plaintext.encode()).decode()

    def decrypt(self, ciphertext: str) -> str:
        """è§£å¯†"""
        return self.cipher.decrypt(ciphertext.encode()).decode()
```

---

## ðŸ“ˆ ç›‘æŽ§ä¸Žåˆ†æž

### å·¥å…·ä½¿ç”¨ç»Ÿè®¡

```sql
-- å·¥å…·ä½¿ç”¨æŽ’è¡Œ
SELECT
    tool_id,
    tool_name,
    COUNT(*) as usage_count,
    AVG(execution_time_ms) as avg_execution_time
FROM tool_usage_logs
WHERE created_at >= NOW() - INTERVAL '30 days'
GROUP BY tool_id, tool_name
ORDER BY usage_count DESC
LIMIT 10;
```

### LLMæˆæœ¬åˆ†æž

```sql
-- æ¯æ—¥LLMæˆæœ¬ç»Ÿè®¡
SELECT
    DATE(created_at) as date,
    provider,
    SUM(cost) as total_cost,
    SUM(total_tokens) as total_tokens
FROM llm_usage
WHERE created_at >= NOW() - INTERVAL '30 days'
GROUP BY DATE(created_at), provider
ORDER BY date DESC;
```

---

## ðŸ—“ï¸ å®žæ–½è·¯çº¿å›¾

### Phase 1ï¼ˆV2ï¼‰ï¼šåŸºç¡€å·¥å…·ç®¡ç†
- [ ] å·¥å…·å®žä½“ä¸ŽRepository
- [ ] é¢„å®šä¹‰å·¥å…·ï¼ˆHTTP, LLM, JavaScriptï¼‰
- [ ] å·¥å…·æ‰§è¡Œå™¨æ¡†æž¶
- [ ] LLMå¤šæä¾›å•†æ”¯æŒï¼ˆOpenAI, DeepSeekï¼‰

### Phase 2ï¼ˆV3ï¼‰ï¼šé«˜çº§åŠŸèƒ½
- [ ] å·¥å…·ç‰ˆæœ¬ç®¡ç†
- [ ] å·¥å…·æµ‹è¯•æ¡†æž¶
- [ ] æˆæœ¬è·Ÿè¸ªä¸Žé¢„ç®—æŽ§åˆ¶
- [ ] å‰ç«¯å·¥å…·é…ç½®ç•Œé¢

### Phase 3ï¼ˆV4+ï¼‰ï¼šå·¥å…·å¸‚åœº
- [ ] å·¥å…·å¸‚åœºåŽç«¯API
- [ ] å·¥å…·å‘çŽ°ä¸Žæœç´¢
- [ ] å·¥å…·è¯„ä»·ç³»ç»Ÿ
- [ ] ä¸€é”®å®‰è£…ä¸Žæ›´æ–°

---

> **æ–‡æ¡£æ›´æ–°**ï¼š
> - æ–°å¢žLLMæä¾›å•†æ—¶æ›´æ–°æ”¯æŒåˆ—è¡¨
> - ä»·æ ¼å˜åŒ–æ—¶æ›´æ–°æˆæœ¬è®¡ç®—é€»è¾‘
> - æ–°å¢žå·¥å…·ç±»åž‹æ—¶è¡¥å……æ‰§è¡Œå™¨å®žçŽ°
