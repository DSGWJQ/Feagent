# å·¥ä½œæµå¯è§†åŒ–æ–¹æ¡ˆ

> **æŠ€æœ¯æ–¹æ¡ˆæ–‡æ¡£**
> é¡¹ç›®åç§°ï¼šFeagent
> æ–‡æ¡£è¯´æ˜ï¼šæœ¬æ–‡æ¡£æè¿°åŸºäºXYFlowçš„å·¥ä½œæµå¯è§†åŒ–å®ç°æ–¹æ¡ˆ

---

## ğŸ¯ æ–¹æ¡ˆæ¦‚è¿°

### å¯è§†åŒ–ç›®æ ‡
1. **æ‰€è§å³æ‰€å¾—**ï¼šæ‹–æ‹½ç¼–è¾‘å·¥ä½œæµï¼Œå®æ—¶ä¿å­˜
2. **æ¸…æ™°ç›´è§‚**ï¼šèŠ‚ç‚¹ç±»å‹å¯è§†åŒ–åŒºåˆ†ï¼ŒçŠ¶æ€å®æ—¶åé¦ˆ
3. **é«˜æ€§èƒ½**ï¼šæ”¯æŒ100+èŠ‚ç‚¹æµç•…æ¸²æŸ“
4. **å¯äº¤äº’**ï¼šåŒå‡»ç¼–è¾‘ã€è¿çº¿åˆ›å»ºã€æ‰¹é‡æ“ä½œ
5. **æ‰§è¡Œç›‘æ§**ï¼šè¿è¡Œæ—¶é«˜äº®å½“å‰èŠ‚ç‚¹ï¼Œæ˜¾ç¤ºæ‰§è¡Œè¿›åº¦

### æŠ€æœ¯é€‰å‹ï¼šXYFlow (React Flow)

#### ä¸ºä»€ä¹ˆé€‰æ‹©XYFlowï¼Ÿ

| ç»´åº¦ | XYFlow (React Flow) | LogicFlow | å…¶ä»–æ–¹æ¡ˆ |
|------|---------------------|-----------|---------|
| **Reacté›†æˆ** | âœ… åŸç”ŸReactç»„ä»¶ | âš ï¸ éœ€é€‚é…å±‚ | âŒ éœ€è‡ªè¡Œå°è£… |
| **TypeScript** | âœ… å®Œæ•´ç±»å‹å®šä¹‰ | âš ï¸ éƒ¨åˆ†æ”¯æŒ | âŒ ç±»å‹ç¼ºå¤± |
| **æ€§èƒ½** | âœ… è™šæ‹ŸåŒ–æ¸²æŸ“ | âœ… ä¸­ç­‰ | âš ï¸ çœ‹å®ç° |
| **æ–‡æ¡£** | âœ… å®Œå–„ï¼ˆè‹±æ–‡ï¼‰ | âš ï¸ è¾ƒå°‘ï¼ˆä¸­æ–‡ï¼‰ | âŒ è‡ªå·±å†™ |
| **ç¤¾åŒº** | âœ… 18k+ stars | âœ… 3k+ stars | - |
| **æ‰©å±•æ€§** | âœ… æ’ä»¶æœºåˆ¶ | âœ… æ”¯æŒ | - |
| **å­¦ä¹ æ›²çº¿** | âš ï¸ ä¸­ç­‰ | âš ï¸ ä¸­ç­‰ | âŒ é«˜ |

**ç»“è®º**ï¼šXYFlowåœ¨Reactç”Ÿæ€ä¸­æœ€æˆç†Ÿï¼Œå·²åœ¨é¡¹ç›®ä¸­å®ç°ï¼Œæ— éœ€æ›´æ¢ã€‚

---

## ğŸ¨ èŠ‚ç‚¹è®¾è®¡

### èŠ‚ç‚¹ç±»å‹ä¸è§†è§‰è®¾è®¡

#### 1. HTTPèŠ‚ç‚¹
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ ğŸŒ HTTPè¯·æ±‚                  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ GET https://api.example.com â”‚
â”‚                             â”‚
â”‚ â— è¾“å…¥                       â”‚
â”‚              è¾“å‡º â—          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**æ ·å¼**ï¼š
- é¢œè‰²ï¼šè“è‰²ï¼ˆ#1890ffï¼‰
- å›¾æ ‡ï¼šğŸŒ åœ°çƒå›¾æ ‡
- æ ‡ç­¾ï¼šæ˜¾ç¤ºHTTPæ–¹æ³•å’ŒURL

#### 2. LLMèŠ‚ç‚¹
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ ğŸ¤– LLMå¤„ç†                   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Model: GPT-4                â”‚
â”‚ Prompt: Translate to...     â”‚
â”‚ â— è¾“å…¥                       â”‚
â”‚              è¾“å‡º â—          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**æ ·å¼**ï¼š
- é¢œè‰²ï¼šç´«è‰²ï¼ˆ#722ed1ï¼‰
- å›¾æ ‡ï¼šğŸ¤– æœºå™¨äººå›¾æ ‡
- æ ‡ç­¾ï¼šæ˜¾ç¤ºæ¨¡å‹å’Œpromptæ‘˜è¦

#### 3. JAVASCRIPTèŠ‚ç‚¹
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ ğŸ“œ JavaScriptè„šæœ¬            â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ return data.filter(...)     â”‚
â”‚                             â”‚
â”‚ â— è¾“å…¥                       â”‚
â”‚              è¾“å‡º â—          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**æ ·å¼**ï¼š
- é¢œè‰²ï¼šé»„è‰²ï¼ˆ#faad14ï¼‰
- å›¾æ ‡ï¼šğŸ“œ è„šæœ¬å›¾æ ‡
- æ ‡ç­¾ï¼šæ˜¾ç¤ºä»£ç ç‰‡æ®µ

#### 4. CONDITIONèŠ‚ç‚¹
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ ğŸ”€ æ¡ä»¶åˆ¤æ–­                   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ if data.status == "success" â”‚
â”‚                             â”‚
â”‚ â— è¾“å…¥                       â”‚
â”‚         True â—   False â—    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**æ ·å¼**ï¼š
- é¢œè‰²ï¼šæ©™è‰²ï¼ˆ#fa8c16ï¼‰
- å›¾æ ‡ï¼šğŸ”€ åˆ†æ”¯å›¾æ ‡
- è¾“å‡ºï¼šä¸¤ä¸ªå¥æŸ„ï¼ˆTrue/Falseï¼‰

#### 5. START/ENDèŠ‚ç‚¹
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  â–¶ å¼€å§‹   â”‚      â”‚  â¹ ç»“æŸ   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**æ ·å¼**ï¼š
- STARTï¼šç»¿è‰²ï¼ˆ#52c41aï¼‰ï¼Œåœ†è§’
- ENDï¼šçº¢è‰²ï¼ˆ#f5222dï¼‰ï¼Œåœ†è§’

### èŠ‚ç‚¹çŠ¶æ€å¯è§†åŒ–

| çŠ¶æ€ | è§†è§‰æ•ˆæœ | è¯´æ˜ |
|------|---------|------|
| **é»˜è®¤** | ç°è‰²è¾¹æ¡† | æœªæ‰§è¡Œ |
| **æ‰§è¡Œä¸­** | è“è‰²è¾¹æ¡† + è„‰å†²åŠ¨ç”» | å½“å‰æ­£åœ¨æ‰§è¡Œ |
| **æˆåŠŸ** | ç»¿è‰²è¾¹æ¡† + âœ…å›¾æ ‡ | æ‰§è¡ŒæˆåŠŸ |
| **å¤±è´¥** | çº¢è‰²è¾¹æ¡† + âŒå›¾æ ‡ | æ‰§è¡Œå¤±è´¥ |
| **è·³è¿‡** | è™šçº¿è¾¹æ¡† | æ¡ä»¶ä¸æ»¡è¶³è·³è¿‡ |

---

## ğŸ”§ æŠ€æœ¯å®ç°

### æ ¸å¿ƒä¾èµ–

```json
{
  "dependencies": {
    "reactflow": "^11.10.0",
    "dagre": "^0.8.5",  // è‡ªåŠ¨å¸ƒå±€ç®—æ³•
    "@ant-design/icons": "^5.2.0"
  }
}
```

### èŠ‚ç‚¹ç»„ä»¶å®ç°

#### åŸºç¡€èŠ‚ç‚¹ç»„ä»¶
```typescript
// web/src/features/workflows/components/nodes/BaseNode.tsx
import { memo } from 'react';
import { Handle, Position, NodeProps } from 'reactflow';
import { Card } from 'antd';
import styles from './BaseNode.module.css';

interface BaseNodeData {
  label: string;
  type: string;
  status?: 'idle' | 'running' | 'success' | 'failed';
  config: Record<string, any>;
}

export const BaseNode = memo(({ data, selected }: NodeProps<BaseNodeData>) => {
  const getStatusColor = () => {
    switch (data.status) {
      case 'running': return '#1890ff';
      case 'success': return '#52c41a';
      case 'failed': return '#f5222d';
      default: return '#d9d9d9';
    }
  };

  return (
    <div className={styles.nodeWrapper}>
      <Handle type="target" position={Position.Top} />

      <Card
        size="small"
        className={styles.nodeCard}
        style={{
          borderColor: getStatusColor(),
          borderWidth: selected ? 2 : 1,
          boxShadow: selected ? '0 0 8px rgba(24, 144, 255, 0.5)' : 'none'
        }}
      >
        <div className={styles.nodeHeader}>
          <span className={styles.nodeIcon}>{getNodeIcon(data.type)}</span>
          <span className={styles.nodeLabel}>{data.label}</span>
        </div>

        <div className={styles.nodeContent}>
          {renderNodeContent(data)}
        </div>
      </Card>

      <Handle type="source" position={Position.Bottom} />
    </div>
  );
});

function getNodeIcon(type: string): string {
  const icons: Record<string, string> = {
    HTTP: 'ğŸŒ',
    LLM: 'ğŸ¤–',
    JAVASCRIPT: 'ğŸ“œ',
    CONDITION: 'ğŸ”€',
    START: 'â–¶',
    END: 'â¹'
  };
  return icons[type] || 'ğŸ“¦';
}

function renderNodeContent(data: BaseNodeData): React.ReactNode {
  switch (data.type) {
    case 'HTTP':
      return (
        <div>
          <div>{data.config.method} {data.config.url}</div>
        </div>
      );
    case 'LLM':
      return (
        <div>
          <div>Model: {data.config.model}</div>
          <div className={styles.truncate}>
            Prompt: {data.config.prompt?.substring(0, 30)}...
          </div>
        </div>
      );
    default:
      return null;
  }
}
```

#### æ¡ä»¶èŠ‚ç‚¹ï¼ˆå¤šè¾“å‡ºå¥æŸ„ï¼‰
```typescript
// web/src/features/workflows/components/nodes/ConditionNode.tsx
import { memo } from 'react';
import { Handle, Position, NodeProps } from 'reactflow';
import { Card } from 'antd';

export const ConditionNode = memo(({ data }: NodeProps) => {
  return (
    <div>
      <Handle type="target" position={Position.Top} />

      <Card size="small" style={{ borderColor: '#fa8c16' }}>
        <div>ğŸ”€ {data.label}</div>
        <div>{data.config.condition}</div>
      </Card>

      {/* å¤šä¸ªè¾“å‡ºå¥æŸ„ */}
      <Handle
        type="source"
        position={Position.Bottom}
        id="true"
        style={{ left: '30%', background: '#52c41a' }}
      />
      <Handle
        type="source"
        position={Position.Bottom}
        id="false"
        style={{ left: '70%', background: '#f5222d' }}
      />
    </div>
  );
});
```

### ç”»å¸ƒä¸»ç»„ä»¶

```typescript
// web/src/features/workflows/components/WorkflowCanvas.tsx
import { useCallback, useState } from 'react';
import ReactFlow, {
  Background,
  Controls,
  MiniMap,
  addEdge,
  useNodesState,
  useEdgesState,
  Connection,
  Edge,
  Node
} from 'reactflow';
import 'reactflow/dist/style.css';
import { BaseNode } from './nodes/BaseNode';
import { ConditionNode } from './nodes/ConditionNode';

const nodeTypes = {
  HTTP: BaseNode,
  LLM: BaseNode,
  JAVASCRIPT: BaseNode,
  CONDITION: ConditionNode,
  START: BaseNode,
  END: BaseNode
};

interface WorkflowCanvasProps {
  workflowId: string;
  initialNodes?: Node[];
  initialEdges?: Edge[];
  onSave?: (nodes: Node[], edges: Edge[]) => void;
}

export function WorkflowCanvas({
  workflowId,
  initialNodes = [],
  initialEdges = [],
  onSave
}: WorkflowCanvasProps) {
  const [nodes, setNodes, onNodesChange] = useNodesState(initialNodes);
  const [edges, setEdges, onEdgesChange] = useEdgesState(initialEdges);

  // è¿æ¥èŠ‚ç‚¹
  const onConnect = useCallback(
    (connection: Connection) => {
      setEdges((eds) => addEdge(connection, eds));
    },
    [setEdges]
  );

  // ä¿å­˜å·¥ä½œæµ
  const handleSave = () => {
    onSave?.(nodes, edges);
  };

  return (
    <div style={{ width: '100%', height: '600px' }}>
      <ReactFlow
        nodes={nodes}
        edges={edges}
        onNodesChange={onNodesChange}
        onEdgesChange={onEdgesChange}
        onConnect={onConnect}
        nodeTypes={nodeTypes}
        fitView
      >
        <Background />
        <Controls />
        <MiniMap />
      </ReactFlow>

      <button onClick={handleSave}>ä¿å­˜å·¥ä½œæµ</button>
    </div>
  );
}
```

---

## ğŸ¬ æ‰§è¡Œç›‘æ§ä¸å®æ—¶æ›´æ–°

### SSEäº‹ä»¶ç›‘å¬

```typescript
// web/src/features/workflows/hooks/useWorkflowExecution.ts
import { useEffect, useState } from 'react';
import { Node } from 'reactflow';

interface ExecutionEvent {
  event: string;
  data: {
    task_id?: string;
    node_id?: string;
    status?: string;
  };
}

export function useWorkflowExecution(runId: string, nodes: Node[]) {
  const [executingNodes, setExecutingNodes] = useState<Set<string>>(new Set());

  useEffect(() => {
    const eventSource = new EventSource(`/api/runs/${runId}/stream`);

    eventSource.onmessage = (e) => {
      if (e.data === '[DONE]') {
        eventSource.close();
        return;
      }

      const event: ExecutionEvent = JSON.parse(e.data);

      // æ›´æ–°èŠ‚ç‚¹çŠ¶æ€
      if (event.event === 'task_started') {
        setExecutingNodes((prev) => new Set([...prev, event.data.node_id!]));
        updateNodeStatus(event.data.node_id!, 'running');
      }

      if (event.event === 'task_completed') {
        setExecutingNodes((prev) => {
          const next = new Set(prev);
          next.delete(event.data.node_id!);
          return next;
        });
        updateNodeStatus(event.data.node_id!, event.data.status!);
      }
    };

    return () => eventSource.close();
  }, [runId]);

  const updateNodeStatus = (nodeId: string, status: string) => {
    // æ›´æ–°å¯¹åº”èŠ‚ç‚¹çš„data.status
    // è§¦å‘React Flowé‡æ–°æ¸²æŸ“
  };

  return { executingNodes };
}
```

### å®æ—¶é«˜äº®æ•ˆæœ

```css
/* BaseNode.module.css */
.nodeCard.running {
  border-color: #1890ff;
  animation: pulse 1.5s ease-in-out infinite;
}

@keyframes pulse {
  0%, 100% {
    box-shadow: 0 0 0 0 rgba(24, 144, 255, 0.7);
  }
  50% {
    box-shadow: 0 0 0 8px rgba(24, 144, 255, 0);
  }
}

.nodeCard.success {
  border-color: #52c41a;
}

.nodeCard.failed {
  border-color: #f5222d;
}
```

---

## ğŸ› ï¸ é«˜çº§åŠŸèƒ½

### 1. è‡ªåŠ¨å¸ƒå±€ï¼ˆDagreï¼‰

```typescript
// web/src/features/workflows/utils/autoLayout.ts
import dagre from 'dagre';
import { Node, Edge } from 'reactflow';

export function autoLayout(nodes: Node[], edges: Edge[]): Node[] {
  const dagreGraph = new dagre.graphlib.Graph();
  dagreGraph.setDefaultEdgeLabel(() => ({}));
  dagreGraph.setGraph({ rankdir: 'TB', nodesep: 100, ranksep: 150 });

  nodes.forEach((node) => {
    dagreGraph.setNode(node.id, { width: 200, height: 80 });
  });

  edges.forEach((edge) => {
    dagreGraph.setEdge(edge.source, edge.target);
  });

  dagre.layout(dagreGraph);

  return nodes.map((node) => {
    const nodeWithPosition = dagreGraph.node(node.id);
    return {
      ...node,
      position: {
        x: nodeWithPosition.x - 100,
        y: nodeWithPosition.y - 40
      }
    };
  });
}
```

### 2. èŠ‚ç‚¹å³é”®èœå•

```typescript
// web/src/features/workflows/components/NodeContextMenu.tsx
import { Menu, Dropdown } from 'antd';
import { NodeProps } from 'reactflow';

export function NodeContextMenu({ id, data }: NodeProps) {
  const menu = (
    <Menu
      items={[
        {
          key: 'edit',
          label: 'ç¼–è¾‘èŠ‚ç‚¹',
          onClick: () => openEditModal(id)
        },
        {
          key: 'duplicate',
          label: 'å¤åˆ¶èŠ‚ç‚¹',
          onClick: () => duplicateNode(id)
        },
        {
          key: 'delete',
          label: 'åˆ é™¤èŠ‚ç‚¹',
          danger: true,
          onClick: () => deleteNode(id)
        }
      ]}
    />
  );

  return (
    <Dropdown overlay={menu} trigger={['contextMenu']}>
      <div>{/* èŠ‚ç‚¹å†…å®¹ */}</div>
    </Dropdown>
  );
}
```

### 3. èŠ‚ç‚¹é…ç½®é¢æ¿

```typescript
// web/src/features/workflows/components/NodeConfigPanel.tsx
import { Drawer, Form, Input, Select } from 'antd';
import { Node } from 'reactflow';

interface NodeConfigPanelProps {
  node: Node | null;
  visible: boolean;
  onClose: () => void;
  onSave: (config: any) => void;
}

export function NodeConfigPanel({
  node,
  visible,
  onClose,
  onSave
}: NodeConfigPanelProps) {
  const [form] = Form.useForm();

  const handleSave = () => {
    const values = form.getFieldsValue();
    onSave(values);
    onClose();
  };

  if (!node) return null;

  return (
    <Drawer
      title={`é…ç½®${node.data.label}`}
      placement="right"
      width={400}
      visible={visible}
      onClose={onClose}
    >
      <Form form={form} layout="vertical" initialValues={node.data.config}>
        {node.type === 'HTTP' && (
          <>
            <Form.Item label="HTTPæ–¹æ³•" name="method">
              <Select>
                <Select.Option value="GET">GET</Select.Option>
                <Select.Option value="POST">POST</Select.Option>
              </Select>
            </Form.Item>
            <Form.Item label="URL" name="url">
              <Input placeholder="https://api.example.com" />
            </Form.Item>
          </>
        )}

        {node.type === 'LLM' && (
          <>
            <Form.Item label="æ¨¡å‹" name="model">
              <Select>
                <Select.Option value="gpt-4">GPT-4</Select.Option>
                <Select.Option value="gpt-3.5-turbo">GPT-3.5 Turbo</Select.Option>
              </Select>
            </Form.Item>
            <Form.Item label="Prompt" name="prompt">
              <Input.TextArea rows={4} />
            </Form.Item>
          </>
        )}

        <button onClick={handleSave}>ä¿å­˜</button>
      </Form>
    </Drawer>
  );
}
```

### 4. èŠ‚ç‚¹æœç´¢ä¸è¿‡æ»¤

```typescript
// web/src/features/workflows/components/NodePalette.tsx
import { Input, Card } from 'antd';
import { useState } from 'react';

const NODE_TYPES = [
  { type: 'HTTP', label: 'HTTPè¯·æ±‚', icon: 'ğŸŒ', category: 'åŸºç¡€' },
  { type: 'LLM', label: 'LLMå¤„ç†', icon: 'ğŸ¤–', category: 'åŸºç¡€' },
  { type: 'JAVASCRIPT', label: 'JavaScript', icon: 'ğŸ“œ', category: 'åŸºç¡€' },
  { type: 'CONDITION', label: 'æ¡ä»¶åˆ¤æ–­', icon: 'ğŸ”€', category: 'é€»è¾‘' }
];

export function NodePalette() {
  const [searchTerm, setSearchTerm] = useState('');

  const filteredNodes = NODE_TYPES.filter((node) =>
    node.label.toLowerCase().includes(searchTerm.toLowerCase())
  );

  const onDragStart = (event: React.DragEvent, nodeType: string) => {
    event.dataTransfer.setData('application/reactflow', nodeType);
    event.dataTransfer.effectAllowed = 'move';
  };

  return (
    <div style={{ width: '200px', padding: '16px' }}>
      <Input
        placeholder="æœç´¢èŠ‚ç‚¹..."
        value={searchTerm}
        onChange={(e) => setSearchTerm(e.target.value)}
      />

      <div style={{ marginTop: '16px' }}>
        {filteredNodes.map((node) => (
          <Card
            key={node.type}
            size="small"
            draggable
            onDragStart={(e) => onDragStart(e, node.type)}
            style={{ marginBottom: '8px', cursor: 'grab' }}
          >
            {node.icon} {node.label}
          </Card>
        ))}
      </div>
    </div>
  );
}
```

---

## ğŸ“Š æ€§èƒ½ä¼˜åŒ–

### è™šæ‹ŸåŒ–æ¸²æŸ“
XYFlowå†…ç½®è™šæ‹ŸåŒ–ï¼Œä»…æ¸²æŸ“å¯è§†åŒºåŸŸå†…çš„èŠ‚ç‚¹ï¼Œæ”¯æŒ1000+èŠ‚ç‚¹æµç•…æ¸²æŸ“ã€‚

### èŠ‚ç‚¹ç¼“å­˜
```typescript
import { memo } from 'react';

export const BaseNode = memo(
  ({ data, selected }: NodeProps) => {
    // ç»„ä»¶å®ç°
  },
  (prevProps, nextProps) => {
    // è‡ªå®šä¹‰æ¯”è¾ƒé€»è¾‘ï¼Œå‡å°‘ä¸å¿…è¦çš„é‡æ¸²æŸ“
    return (
      prevProps.data === nextProps.data &&
      prevProps.selected === nextProps.selected
    );
  }
);
```

### è¾¹çš„æ‰¹é‡æ›´æ–°
```typescript
// é¿å…é€ä¸ªæ›´æ–°ï¼Œä½¿ç”¨æ‰¹é‡æ›´æ–°
setEdges((edges) => [
  ...edges,
  ...newEdges  // ä¸€æ¬¡æ€§æ·»åŠ å¤šæ¡è¾¹
]);
```

---

## ğŸ¯ æœªæ¥å¢å¼º

### V2å¢å¼º
- [ ] å­å·¥ä½œæµèŠ‚ç‚¹ï¼ˆåµŒå¥—å·¥ä½œæµï¼‰
- [ ] å¾ªç¯èŠ‚ç‚¹ï¼ˆæ‰¹é‡å¤„ç†ï¼‰
- [ ] å¹¶è¡ŒèŠ‚ç‚¹ï¼ˆåŒæ—¶æ‰§è¡Œå¤šä¸ªåˆ†æ”¯ï¼‰

### V3å¢å¼º
- [ ] åä½œç¼–è¾‘ï¼ˆå¤šç”¨æˆ·åŒæ—¶ç¼–è¾‘ï¼‰
- [ ] ç‰ˆæœ¬å†å²ï¼ˆå·¥ä½œæµå¿«ç…§ï¼‰
- [ ] è¯„è®ºç³»ç»Ÿï¼ˆèŠ‚ç‚¹ä¸Šæ·»åŠ æ³¨é‡Šï¼‰

### V4å¢å¼º
- [ ] AIè¾…åŠ©å¸ƒå±€ï¼ˆæ™ºèƒ½ä¼˜åŒ–èŠ‚ç‚¹ä½ç½®ï¼‰
- [ ] æ™ºèƒ½æ¨èèŠ‚ç‚¹ï¼ˆæ ¹æ®ä¸Šä¸‹æ–‡æ¨èä¸‹ä¸€æ­¥ï¼‰
- [ ] æ‰§è¡Œå›æ”¾ï¼ˆæ—¶é—´è½´å›æ”¾æ‰§è¡Œè¿‡ç¨‹ï¼‰

---

> **æ–‡æ¡£æ›´æ–°**ï¼š
> - XYFlowç‰ˆæœ¬å‡çº§æ—¶æ›´æ–°APIç”¨æ³•
> - æ–°å¢èŠ‚ç‚¹ç±»å‹æ—¶è¡¥å……è§†è§‰è®¾è®¡è§„èŒƒ
> - æ€§èƒ½ä¼˜åŒ–åè®°å½•ä¼˜åŒ–æ–¹æ³•å’Œæ•ˆæœ
